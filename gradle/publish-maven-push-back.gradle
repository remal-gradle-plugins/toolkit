import static java.util.stream.Collectors.toList

import java.util.concurrent.ThreadLocalRandom
import org.gradle.api.internal.artifacts.ivyservice.ivyresolve.strategy.DefaultVersionComparator
import org.gradle.api.internal.artifacts.ivyservice.ivyresolve.strategy.VersionParser

if (project.isBuildSrcProject) {
    return
}

String publishedVersionsDirRelativePath = '.published'
project.publishedVersionsDirRelativePath.set(publishedVersionsDirRelativePath)

tasks.register('pushBackPublishedVersions') { Task task ->
    task.group = 'documentation'
    task.outputs.upToDateWhen { false }

    ListProperty<MavenPublication> allMavenPublications = objects.listProperty(MavenPublication).value(provider {
        project.allprojects.stream()
            .filter { it.pluginManager.hasPlugin('maven-publish') }
            .flatMap { it.publishing.publications.withType(MavenPublication).stream() }
            .map { MavenPublication.cast(it) }
            .collect(toList())
    }).with { it.finalizeValueOnRead(); it }

    doLast {
        Collection<String> versionFilePaths = new LinkedHashSet<>()
        allMavenPublications.get().forEach { MavenPublication publication ->
            String versionFilePath = "$publishedVersionsDirRelativePath/${publication.groupId}/${publication.artifactId}.version"
            if (!versionFilePaths.add(versionFilePath)) {
                return
            }

            int maxAttempts = 3
            for (int attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    logger.quiet(
                        "Reporting {}:{} version {} to {}",
                        publication.groupId,
                        publication.artifactId,
                        publication.version,
                        versionFilePath
                    )
                    Map existingFileInfo = sendGitHubRestApiRequest(
                        "contents/${URLDecoder.decode(versionFilePath, 'UTF-8')}",
                    )
                    if (existingFileInfo == null) {
                        logger.quiet("    File does not exist, creating")
                    } else {
                        logger.quiet("    Existing file info:")
                        logger.quiet("        Type: {}", existingFileInfo.type)
                        logger.quiet("        SHA: {}", existingFileInfo.sha)
                        logger.quiet("        URL: {}", existingFileInfo.url)
                        logger.quiet("        HTML URL: {}", existingFileInfo.html_url)
                        logger.quiet("        Download URL: {}", existingFileInfo.download_url)
                        logger.quiet("        Encoded content ({}): {}", existingFileInfo.encoding, existingFileInfo.content)
                    }

                    String prevContent = existingFileInfo?.content?.with {
                        new String(Base64.decoder.decode(it), "UTF-8").trim()
                    }
                    String nextContent = publication.version
                    if (prevContent != null) {
                        logger.quiet("    Previously published version: {}", prevContent)
                        VersionParser parser = new VersionParser()
                        def prevVer = parser.transform(prevContent)
                        def nextVer = parser.transform(nextContent)
                        Comparator versionComparator = new DefaultVersionComparator().asVersionComparator()
                        int comparisonResult = versionComparator.compare(prevVer, nextVer)
                        if (comparisonResult == 0) {
                            logger.quiet("    Version {} has been already reported", nextContent)
                            return
                        } else if (comparisonResult > 0) {
                            logger.quiet("    Version {} is less than what was already reported: {}", nextContent, prevContent)
                            return
                        }
                    }

                    sendGitHubRestApiRequest(
                        "contents/${URLDecoder.decode(versionFilePath, 'UTF-8')}",
                        'PUT',
                        [
                            message: "[no-changelog] Update $versionFilePath",
                            content: Base64.encoder.encodeToString(nextContent.getBytes('UTF-8')),
                            sha: existingFileInfo?.sha
                        ],
                    )

                } catch (Exception exception) {
                    if (isHttpRequestFailedException(exception)) {
                        int statusCode = exception.statusCode.toString().toInteger().intValue()
                        logger.error("    Failed with status code {}", statusCode)
                        if (400 <= statusCode && statusCode <= 499) {
                            if ([408, 409, 412, 423].contains(statusCode)) {
                                // retryable
                            } else {
                                throw exception // non-retryable
                            }
                        }
                        if (attempt >= maxAttempts) {
                            throw exception
                        }
                        logger.quiet("    Retrying attempt {}/{}...", attempt, maxAttempts)
                        Thread.sleep(ThreadLocalRandom.current().nextLong(2_500, 7_500))
                        continue
                    }

                    throw exception
                }
            }
        }
    }
}
