allprojects {
    pluginManager.withPlugin('java-gradle-plugin') {
        afterEvaluate {
            configurations.all { Configuration conf ->
                conf.dependencies.removeIf {
                    it instanceof FileCollectionDependency && it.files.toString() != 'file collection'
                }
            }
        }

        testSourceSets.create('functional')

        dependencies {
            optional 'name.remal.gradle-api:gradle-api'

            testImplementation 'name.remal.gradle-api:gradle-test-kit'
        }


        ext['getCorrespondingKotlinVersion'] = rootProject.findProperty('getCorrespondingKotlinVersion') ?: {
            Dependency apiDep = project.dependencies.create(
                "name.remal.gradle-api:gradle-api:${property('gradle-api.version')}"
            )
            Configuration tempConf = configurations.detachedConfiguration(apiDep)
            ResolvedDependency kotlinDep = tempConf.resolvedConfiguration
                .lenientConfiguration
                .allModuleDependencies
                .find { it.moduleGroup == 'org.jetbrains.kotlin' }

            return kotlinDep?.moduleVersion
        }.memoize()

        tasks.matching { it instanceof JavaForkOptions }.configureEach {
            String correspondingKotlinVersion = getCorrespondingKotlinVersion()
            if (correspondingKotlinVersion != null) {
                onlyIf {
                    systemProperty('corresponding-kotlin.version', correspondingKotlinVersion)
                    return true
                }
            }
        }

        configurations.create('correspondingKotlinPlugin') { Configuration conf ->
            conf.defaultDependencies { deps ->
                String correspondingKotlinVersion = getCorrespondingKotlinVersion()
                if (correspondingKotlinVersion != null) {
                    Dependency kotlinPluginDep = project.dependencies.create(
                        "org.jetbrains.kotlin:kotlin-gradle-plugin:${correspondingKotlinVersion}"
                    ) {
                        exclude group: 'commons-logging', module: 'commons-logging'
                        exclude group: 'com.google.code.findbugs'
                        exclude group: 'org.checkerframework'
                        exclude group: 'com.google.errorprone'
                        exclude group: 'com.google.j2objc', module: 'j2objc-annotations'
                    }

                    deps.add(kotlinPluginDep)
                }
            }

            conf.extendsFrom = []
            conf.description('Kotlin Gradle plugin os the same version, as Kotlin that bundled in the current Gradle instance')
        }


        tasks.register('collectGradlePluginApiDependencies') {
            List<Configuration> configurations = ['api', 'indirectApi'].collect { project.configurations.getByName(it) }
            configurations.forEach { it.canBeResolved = true }
            configurations.forEach { conf ->
                inputs.files(conf)
                    .optional()
                    .withNormalizer(ClasspathNormalizer)
                    .withPathSensitivity(PathSensitivity.RELATIVE)
                    .withPropertyName("${conf.name}Configuration")
            }

            File outputFile = project.file("${project.buildDir}/gradle-plugin-api-dependencies.txt")
            outputs.file(outputFile).withPropertyName('outputFile')
            doFirst { outputFile.delete() }

            doLast {
                outputFile.parentFile.mkdirs()

                Collection<String> dependencies = new TreeSet<String>()
                configurations.forEach { conf ->
                    conf.resolvedConfiguration.resolvedArtifacts.forEach { artifact ->
                        ComponentIdentifier untypedComponentIdentifier = artifact.id.componentIdentifier
                        if (!(untypedComponentIdentifier instanceof ModuleComponentIdentifier)) return
                        ModuleComponentIdentifier componentIdentifier = (ModuleComponentIdentifier) untypedComponentIdentifier
                        if (artifact.type !== 'jar') return
                        String notation = "${componentIdentifier.group}:${componentIdentifier.module}:${componentIdentifier.version}:${artifact.classifier ?: ''}@${artifact.extension}"
                        notation = notation.replaceFirst(/:?@(jar)?$/, '')
                        dependencies.add(notation)
                    }
                }

                outputFile.setText(dependencies.join('\n') + '\n', 'UTF-8')
            }
        }
    }
}


tasks.create('collectAllGradlePluginApiDependencies') {
    Closure<List<Task>> getCollectGradlePluginApiDependenciesTasks = {
        project.allprojects
            .findAll { it.pluginManager.hasPlugin('java-gradle-plugin') }
            .collect { it.tasks.getByName('collectGradlePluginApiDependencies') }
    }.memoize()
    dependsOn(project.provider { getCollectGradlePluginApiDependenciesTasks() })

    Closure<List<File>> getGradlePluginApiDependenciesFiles = {
        getCollectGradlePluginApiDependenciesTasks().collect {
            it.project.file("${it.project.buildDir}/gradle-plugin-api-dependencies.txt")
        }
    }.memoize()
    inputs.files(project.provider { getGradlePluginApiDependenciesFiles() })
        .optional()
        .withPathSensitivity(PathSensitivity.RELATIVE)
        .withPropertyName('gradlePluginApiDependenciesFiles')

    File outputFile = project.file("gradle-plugin-api-dependencies.txt")
    outputs.file(outputFile).withPropertyName('outputFile')
    doFirst { outputFile.delete() }

    doLast {
        outputFile.parentFile.mkdirs()

        Collection<String> dependencies = new TreeSet<String>()
        getGradlePluginApiDependenciesFiles().forEach { file ->
            file.getText('UTF-8').split(/\n/)
                .collect { it.trim() }
                .findAll { !it.isEmpty() }
                .forEach { dependencies.add(it) }
        }
        outputFile.setText(dependencies.join('\n') + '\n', 'UTF-8')
    }
}
