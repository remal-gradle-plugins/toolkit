allprojects {
    pluginManager.withPlugin('java-gradle-plugin') {
        afterEvaluate {
            configurations.all { Configuration conf ->
                conf.dependencies.removeIf {
                    it instanceof FileCollectionDependency && it.files.toString() != 'file collection'
                }
            }
        }

        testSourceSets.create('functional')

        dependencies {
            optional 'name.remal.gradle-api:gradle-api'
            testImplementation 'name.remal.gradle-api:gradle-test-kit'
        }


        ext['getCorrespondingKotlinVersion'] = rootProject.findProperty('getCorrespondingKotlinVersion') ?: {
            Dependency apiDep = project.dependencies.create(
                "name.remal.gradle-api:gradle-api:${property('gradle-api.version')}"
            )
            Configuration tempConf = configurations.detachedConfiguration(apiDep)
            ResolvedDependency kotlinDep = tempConf.resolvedConfiguration
                .lenientConfiguration
                .allModuleDependencies
                .find { it.moduleGroup == 'org.jetbrains.kotlin' }

            return kotlinDep?.moduleVersion
        }.memoize()

        tasks.matching { it instanceof JavaForkOptions }.configureEach {
            String correspondingKotlinVersion = getCorrespondingKotlinVersion()
            if (correspondingKotlinVersion != null) {
                onlyIf {
                    systemProperty('corresponding-kotlin.version', correspondingKotlinVersion)
                    return true
                }
            }
        }

        configurations.create('correspondingKotlinPlugin') { Configuration conf ->
            conf.defaultDependencies { deps ->
                String correspondingKotlinVersion = getCorrespondingKotlinVersion()
                if (correspondingKotlinVersion != null) {
                    Dependency kotlinPluginDep = project.dependencies.create(
                        "org.jetbrains.kotlin:kotlin-gradle-plugin:${correspondingKotlinVersion}"
                    ) {
                        exclude group: 'commons-logging', module: 'commons-logging'
                        exclude group: 'com.google.code.findbugs'
                        exclude group: 'org.checkerframework'
                        exclude group: 'com.google.errorprone'
                        exclude group: 'com.google.j2objc', module: 'j2objc-annotations'
                    }

                    deps.add(kotlinPluginDep)
                }
            }

            conf.extendsFrom = []
            conf.description('Kotlin Gradle plugin os the same version, as Kotlin that bundled in the current Gradle instance')
        }


        Configuration gradlePluginApiDependenciesConf = configurations.create('gradlePluginApiDependencies') { Configuration conf ->
            conf.extendsFrom(configurations.api)
            conf.extendsFrom(configurations.indirectApi)
        }

        Configuration gradlePluginPlatformApiDependenciesConf = configurations.create('gradlePluginPlatformApiDependencies') { Configuration conf ->
            conf.extendsFrom(configurations.platformApi)
        }

        tasks.register('collectGradlePluginApiDependencies') {
            [
                gradlePluginApiDependenciesConf,
                gradlePluginPlatformApiDependenciesConf,
            ].forEach { inputConf ->
                inputs.files(inputConf)
                    .optional()
                    .withNormalizer(ClasspathNormalizer)
                    .withPathSensitivity(PathSensitivity.RELATIVE)
                    .withPropertyName(inputConf.name)
            }

            File outputFile = project.file("${project.buildDir}/gradle-plugin-api-dependencies.txt")
            outputs.file(outputFile).withPropertyName('outputFile')
            doFirst { outputFile.delete() }

            doLast {
                outputFile.parentFile.mkdirs()

                Collection<String> dependencies = new TreeSet<String>()

                Collection<ResolvedArtifact> resolvedArtifacts = gradlePluginApiDependenciesConf.resolvedConfiguration.resolvedArtifacts

                Closure<Boolean> isExcludedCategory = { ResolvedDependencyResult resolvedDependency ->
                    return isPlatformDependency(resolvedDependency) || isDocumentationDependency(resolvedDependency) || isVerificationDependency(resolvedDependency)
                }

                Closure processResolvedDependency = { ResolvedDependencyResult resolvedDependency ->
                    ComponentIdentifier componentIdentifierUntyped = resolvedDependency.selected.id
                    if (!(componentIdentifierUntyped instanceof ModuleComponentIdentifier)) {
                        return
                    }
                    ModuleComponentIdentifier componentIdentifier = (ModuleComponentIdentifier) componentIdentifierUntyped

                    if (isPlatformDependency(resolvedDependency)) {
                        String notation = "${componentIdentifier.group}:${componentIdentifier.module}:${componentIdentifier.version}"
                        dependencies.add(notation)
                        return
                    }

                    Collection<ResolvedArtifact> dependencyArtifacts = resolvedArtifacts.findAll { it.id.componentIdentifier == componentIdentifier }
                    dependencyArtifacts.forEach { dependencyArtifact ->
                        String notation = "${componentIdentifier.group}:${componentIdentifier.module}:${componentIdentifier.version}:${dependencyArtifact.classifier ?: ''}@${dependencyArtifact.extension}"
                        notation = notation.replaceFirst(/:?@(jar)?$/, '')
                        dependencies.add(notation)
                    }
                }

                gradlePluginApiDependenciesConf.incoming.resolutionResult
                    .root
                    .dependencies
                    .findAll { it instanceof ResolvedDependencyResult }
                    .collect { (ResolvedDependencyResult) it }
                    .findAll { !isExcludedCategory(it) }
                    .forEach { processResolvedDependency(it) }

                gradlePluginApiDependenciesConf.incoming.resolutionResult
                    .allDependencies
                    .findAll { it instanceof ResolvedDependencyResult }
                    .collect { (ResolvedDependencyResult) it }
                    .findAll { !isExcludedCategory(it) }
                    .findAll { !it.selected.selectionReason.expected }
                    .forEach { processResolvedDependency(it) }


                gradlePluginPlatformApiDependenciesConf.incoming.resolutionResult
                    .allDependencies
                    .findAll { it instanceof ResolvedDependencyResult }
                    .collect { (ResolvedDependencyResult) it }
                    .findAll { isPlatformDependency(it) }
                    .forEach { processResolvedDependency(it) }


                outputFile.setText(dependencies.join('\n') + '\n', 'UTF-8')
            }
        }
    }
}


tasks.create('collectAllGradlePluginApiDependencies') {
    Closure<List<Task>> getCollectGradlePluginApiDependenciesTasks = {
        project.allprojects
            .findAll { it.pluginManager.hasPlugin('java-gradle-plugin') }
            .collect { it.tasks.getByName('collectGradlePluginApiDependencies') }
    }.memoize()
    dependsOn(project.provider { getCollectGradlePluginApiDependenciesTasks() })

    Closure<List<File>> getGradlePluginApiDependenciesFiles = {
        getCollectGradlePluginApiDependenciesTasks().collect {
            it.project.file("${it.project.buildDir}/gradle-plugin-api-dependencies.txt")
        }
    }.memoize()
    inputs.files(project.provider { getGradlePluginApiDependenciesFiles() })
        .optional()
        .withPathSensitivity(PathSensitivity.RELATIVE)
        .withPropertyName('gradlePluginApiDependenciesFiles')

    File outputFile = project.file("gradle-plugin-api-dependencies.txt")
    outputs.file(outputFile).withPropertyName('outputFile')
    doFirst { outputFile.delete() }

    doLast {
        outputFile.parentFile.mkdirs()

        Collection<String> dependencies = new TreeSet<String>()
        getGradlePluginApiDependenciesFiles().forEach { file ->
            file.getText('UTF-8').split(/\n/)
                .collect { it.replaceFirst(/#.*/, '') }
                .collect { it.trim() }
                .findAll { !it.isEmpty() }
                .forEach { dependencies.add(it) }
        }
        outputFile.setText(
            [
                "# This file is generated automatically by `${it.name}` Gradle task.",
                '# Do not modify it yourself unless you know what you are doing.',
                '',
                dependencies.join('\n'),
                '',
            ].join('\n'),
            'UTF-8'
        )
    }
}
