import org.gradle.api.internal.tasks.compile.HasCompileOptions

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

allprojects {
    pluginManager.withPlugin('java') {
        java {
            sourceCompatibility = targetCompatibility = project.javaRuntimeMinVersion

            consistentResolution {
                //useCompileClasspathVersions()
            }
        }

        repositories {
            mavenCentral()
            gradlePluginPortal()

            exclusiveContent {
                forRepository {
                    maven {
                        name = 'Gradle API'
                        url = 'https://maven.pkg.github.com/remal-gradle-api/packages'
                        credentials {
                            username = System.getenv('GITHUB_ACTOR') ?: 'x-access-token'
                            password = System.getenv('READ_PACKAGES_GITHUB_TOKEN') ?:
                                'g' + 'hp_xmGQ2dHvCiK685' + 'qNEFuA3IAvv6Vfg62WM1hG'
                        }
                    }
                }
                filter {
                    includeGroup('name.remal.gradle-api')
                }
            }
        }

        configurations.create('indirectApi') { Configuration conf ->
            conf.canBeResolved = false
            conf.canBeConsumed = false
            conf.description = "Indirect API dependencies (form example: default dependencies for configurations that are created by the plugin)"
        }

        configurations.create('compileOnlyAll') { Configuration conf ->
            conf.canBeResolved = false
            conf.canBeConsumed = false
            conf.description = "Compile-only dependencies for all source-sets"
            sourceSets.all { SourceSet sourceSet ->
                configurations[sourceSet.compileOnlyConfigurationName].extendsFrom(conf)
            }
        }

        configurations.create('optional') { Configuration conf ->
            conf.canBeResolved = false
            conf.canBeConsumed = false
            conf.description = "Optional dependencies"
            sourceSets.all { SourceSet sourceSet ->
                if (sourceSet.name == SourceSet.MAIN_SOURCE_SET_NAME) {
                    configurations[sourceSet.compileOnlyConfigurationName].extendsFrom(conf)
                } else {
                    configurations[sourceSet.implementationConfigurationName].extendsFrom(conf)
                }
            }
        }

        configurations.create('optionalHidden') { Configuration conf ->
            conf.canBeResolved = true
            conf.canBeConsumed = false
            conf.description = "Optional dependencies hidden from IDE"

            tasks.withType(AbstractCompile).configureEach { AbstractCompile task ->
                onlyIf {
                    task.classpath += conf
                    return true
                }
            }

            tasks.withType(Javadoc).configureEach { Javadoc task ->
                onlyIf {
                    task.classpath += conf
                    return true
                }
            }

            tasks.withType(Test).configureEach { Test task ->
                onlyIf {
                    task.classpath += conf
                    return true
                }
            }
        }

        configurations.create('apt') { Configuration conf ->
            conf.canBeResolved = false
            conf.canBeConsumed = false
            conf.description = "Annotation processors and compile-only dependencies for all source-sets"
            sourceSets.all { SourceSet sourceSet ->
                configurations[sourceSet.annotationProcessorConfigurationName].extendsFrom(conf)
                configurations[sourceSet.compileOnlyConfigurationName].extendsFrom(conf)
            }
        }

        configurations.create('annotationProcessorAll') { Configuration conf ->
            conf.canBeResolved = false
            conf.canBeConsumed = false
            conf.description = "Annotation processors for all source-sets"
            sourceSets.all { SourceSet sourceSet ->
                configurations[sourceSet.annotationProcessorConfigurationName].extendsFrom(conf)
            }
        }

        configurations.create('compileConstraints') { Configuration conf ->
            conf.canBeResolved = false
            conf.canBeConsumed = false
            conf.description = "Constraints for compile-time dependencies"
            sourceSets.all { SourceSet sourceSet ->
                configurations[sourceSet.annotationProcessorConfigurationName].extendsFrom(conf)
                configurations[sourceSet.compileOnlyConfigurationName].extendsFrom(conf)
            }
            configurations.optionalHidden.extendsFrom(conf)
        }

        String autoService = '1.1.1'

        dependencies {
            compileConstraints platform('org.immutables:bom:2.11.2')

            compileOnlyAll 'com.google.code.findbugs:jsr305:3.0.2'
            compileOnlyAll 'org.jetbrains:annotations:26.0.2'
            optionalHidden 'com.github.spotbugs:spotbugs-annotations:4.9.4'

            annotationProcessorAll "com.google.auto.service:auto-service:$autoService"
            compileOnlyAll "com.google.auto.service:auto-service-annotations:$autoService"
            annotationProcessorAll 'org.immutables:value'
            compileOnlyAll 'org.immutables:value-annotations'
            compileOnlyAll 'org.immutables:builder'
            compileOnlyAll('org.immutables:gson') {
                exclude(group: 'com.google.code.gson', module: 'gson')
            }
            optionalHidden 'org.immutables:gson'
        }

        sourceSets.all { SourceSet sourceSet ->
            project.configurations[sourceSet.compileClasspathConfigurationName].attributes { attrs ->
                attrs.attribute(
                    LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE,
                    objects.named(LibraryElements, LibraryElements.JAR)
                )
            }
            project.configurations[sourceSet.runtimeClasspathConfigurationName].attributes { attrs ->
                attrs.attribute(
                    LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE,
                    objects.named(LibraryElements, LibraryElements.JAR)
                )
            }
        }


        tasks.matching({ it instanceof HasCompileOptions }).configureEach { HasCompileOptions task ->
            task.options.with {
                fork = false
                incremental = false
                encoding = 'UTF-8'
                deprecation = true
                compilerArgs.addAll([
                    '-parameters',
                    '-Werror',
                    '-Xlint:all',
                    '-Xlint:-rawtypes',
                    '-Xlint:-serial',
                    '-Xlint:-processing',
                ])
            }

            if (task instanceof JavaCompile) {
                task.onlyIf {
                    int compilerLanguageVersion = task.javaCompiler.get().metadata.languageVersion.asInt()
                    if (compilerLanguageVersion >= 21) {
                        task.options.compilerArgs.addAll([
                            '-Xlint:-this-escape',
                        ])
                    }
                    return true
                }
            }
        }

        tasks.withType(JavaCompile).configureEach {
            onlyIf {
                JavaVersion compatibilityVersion = JavaVersion.toVersion(targetCompatibility)
                options.release = Integer.parseInt(compatibilityVersion.majorVersion)
                return true
            }
        }


        tasks.named(sourceSets.main.jarTaskName, Jar) {
            onlyIf {
                manifest {
                    attributes(
                        'Automatic-Module-Name': project.calculateJavaModuleName()
                    )
                }
                return true
            }
        }


        project.sourceSets.all { SourceSet sourceSet ->
            project.tasks.withType(AbstractCopyTask)
                .matching { it.name == sourceSet.sourcesJarTaskName }
                .configureEach { AbstractCopyTask task ->
                    task.exclude('**/internal', '**/internal/**/*')
                }
        }
    }
}
