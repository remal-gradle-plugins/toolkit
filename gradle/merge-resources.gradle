allprojects {
    tasks.withType(AbstractCopyTask).configureEach { AbstractCopyTask task ->
        task.duplicatesStrategy = DuplicatesStrategy.FAIL
        task.filteringCharset = 'UTF-8'

        task.doFirst {
            Map<RelativePath, Collection<File>> filesToMerge = new LinkedHashMap<>()
            task.rootSpec.buildRootResolver().allSource.asFileTree
                .matching { include('META-INF/services/*') }
                .visit { FileVisitDetails details ->
                    if (details.directory) return;
                    filesToMerge.computeIfAbsent(details.relativePath, { new LinkedHashSet<>() }).add(details.file)
                }

            File mergedFilesDir = new File(task.temporaryDir.absolutePath + '.merged-services')
            mergedFilesDir.delete()
            mergedFilesDir.deleteDir()

            filesToMerge.values().removeIf { it.size() <= 1 }
            if (filesToMerge.isEmpty()) return;

            mergedFilesDir.mkdirs()
            task.from(mergedFilesDir)

            filesToMerge.forEach { RelativePath relativePath, Collection<File> files ->
                File mergedFile = new File(mergedFilesDir, relativePath.toString())
                mergedFile.delete()
                mergedFile.parentFile.mkdirs()

                String content = files.collect { it.getText('UTF-8') }.join('\n\n')
                content = content.replace('\r\n', '\n')
                    .replace('\n\r', '\n')
                    .replace('\r', '\n')
                    .split('\n')
                    .collect { it.replaceFirst(/\s*$/, '') }
                    .join('\n')
                if (!content.contains('#')) {
                    content = content.replaceAll(/\n{2,}/, '\n')
                }
                mergedFile.setText(content, 'UTF-8')
            }

            task.exclude { FileTreeElement element ->
                Collection<File> mergedFiles = filesToMerge[element.relativePath]
                if (mergedFiles != null) {
                    File file = element.file
                    return mergedFiles.contains(file)
                }
                return false
            }
        }

        task.doFirst {
            Map<RelativePath, Collection<File>> filesToMerge = new LinkedHashMap<>()
            task.rootSpec.buildRootResolver().allSource.asFileTree
                .matching { include('META-INF/classes-relying-on-internal-gradle-api-hashes.txt') }
                .visit { FileVisitDetails details ->
                    if (details.directory) return;
                    filesToMerge.computeIfAbsent(details.relativePath, { new LinkedHashSet<>() }).add(details.file)
                }

            File mergedFilesDir = new File(task.temporaryDir.absolutePath + '.merged-internal-gradle-api-hashes')
            mergedFilesDir.delete()
            mergedFilesDir.deleteDir()

            filesToMerge.values().removeIf { it.size() <= 1 }
            if (filesToMerge.isEmpty()) return;

            mergedFilesDir.mkdirs()
            task.from(mergedFilesDir)

            filesToMerge.forEach { RelativePath relativePath, Collection<File> files ->
                File mergedFile = new File(mergedFilesDir, relativePath.toString())
                mergedFile.delete()
                mergedFile.parentFile.mkdirs()

                String content = files.collect { it.getText('UTF-8') }.join('\n')
                content = content
                    .split(/[\r\n]/)
                    .collect { it.trim() }
                    .findAll { !it.isEmpty() }
                    .toSorted()
                    .join('\n')
                mergedFile.setText(content, 'UTF-8')
            }

            task.exclude { FileTreeElement element ->
                Collection<File> mergedFiles = filesToMerge[element.relativePath]
                if (mergedFiles != null) {
                    File file = element.file
                    return mergedFiles.contains(file)
                }
                return false
            }
        }
    }
}
