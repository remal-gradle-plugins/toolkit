import static org.gradle.api.attributes.Category.CATEGORY_ATTRIBUTE
import static org.gradle.api.attributes.Category.DOCUMENTATION
import static org.gradle.api.attributes.Category.ENFORCED_PLATFORM
import static org.gradle.api.attributes.Category.REGULAR_PLATFORM
import static org.gradle.api.attributes.Category.VERIFICATION

import com.vdurmont.semver4j.Semver
import java.lang.reflect.Method
import java.lang.reflect.Modifier
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentMap
import org.gradle.util.GradleVersion
import org.json.JSONArray
import org.json.JSONObject
import org.json.JSONTokener

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

buildscript {
    dependencies {
        classpath "org.json:json:${rootBuildscriptClasspathVersionOf('org.json:json')}"
        classpath "com.vdurmont:semver4j:${rootBuildscriptClasspathVersionOf('com.vdurmont:semver4j')}"
    }
    repositories {
        mavenCentral()
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

Object MUTEX = new Object[0]

project.ext.startWithWord = { CharSequence untypedString, CharSequence untypedNeedle ->
    if (untypedString == null || untypedNeedle == null) return false
    if (untypedNeedle.length() == 0) return true
    if (untypedString.length() == 0) return false
    String string = untypedString.toString()
    String needle = untypedNeedle.toString()
    if (string == needle) return true
    if (string.startsWith(needle)) {
        String remaining = string.substring(needle.length())
        char firstRemainingChar = remaining.charAt(0)
        char lastNeedleChar = needle.charAt(needle.length() - 1)
        if (Character.isDigit(lastNeedleChar)) {
            return !Character.isDigit(firstRemainingChar)
        } else if (Character.isLetter(lastNeedleChar)) {
            if (!Character.isLetter(lastNeedleChar)) {
                return true
            } else if (Character.isUpperCase(firstRemainingChar) && !Character.isUpperCase(lastNeedleChar)) {
                return true
            } else if (Character.isLowerCase(firstRemainingChar) && !Character.isLowerCase(lastNeedleChar)) {
                return true
            } else {
                return false
            }
        } else {
            return Character.isLetter(firstRemainingChar)
        }
    }
    return false
}

project.ext.isInstanceOf = { Object object, String parentClassName ->
    if (object == null) return false

    Class<?> parentClass = Class.forName(parentClassName, true, object.class.classLoader)
    return parentClass.isInstance(object)
}

project.ext.disableTask = { Task task ->
    task.enabled = false
    task.onlyIf { false }
    task.dependsOn = []
    Iterator registeredFileProperties = task.inputs.registeredFileProperties.iterator()
    while (registeredFileProperties.hasNext()) {
        registeredFileProperties.next()
        registeredFileProperties.remove()
    }
}

project.ext.isVerificationTask = { Task task ->
    if (task instanceof AbstractTestTask) {
        return true
    }
    if (task instanceof VerificationTask) {
        return true
    }
    if (task instanceof ValidatePlugins) {
        return true
    }
    return false
}


List<Method> sourceSetGetConfigurationNameMethods = SourceSet.getMethods().findAll {
    it.name.startsWith('get')
        && it.name.endsWith('ConfigurationName')
        && it.returnType == String
        && it.parameterCount == 0
        && !Modifier.isStatic(it.modifiers)
}
project.ext.getSourceSetConfigurationNames = { SourceSet sourceSet ->
    return sourceSetGetConfigurationNameMethods.collect { it.invoke(sourceSet) }
        .findAll { it != null }
        .toSet()
}

allprojects {
    project.ext.allSourceSetConfigurations = { SourceSet sourceSet, Closure action ->
        Collection<String> sourceSetConfigurationNames = project.getSourceSetConfigurationNames(sourceSet)
        project.configurations.matching { sourceSetConfigurationNames.contains(it.name) }.all { action(it) }
    }
}


project.ext.getDependencyCategory = { Object dep ->
    AttributeContainer attributes = null
    if (dep instanceof ModuleDependency) {
        attributes = dep.attributes
    } else if (dep instanceof ResolvedDependencyResult) {
        attributes = dep.resolvedVariant.attributes
    } else if (dep instanceof Dependency) {
        return false
    } else {
        throw new GradleException("Unsupported dependency type: ${dep.class}")
    }

    Attribute categoryAttribute = attributes.keySet().find { attr ->
        if (attr instanceof String) {
            return attr == CATEGORY_ATTRIBUTE.name
        } else {
            return attr.name == CATEGORY_ATTRIBUTE.name
        }
    }
    if (categoryAttribute == null) {
        return null;
    }

    Object value = attributes.getAttribute(categoryAttribute)
    if (value instanceof String) {
        return value
    }
    return value.name
}

project.ext.isPlatformDependency = { Object dep ->
    String category = getDependencyCategory(dep)
    return [REGULAR_PLATFORM, ENFORCED_PLATFORM].contains(category)
}

project.ext.isEnforcedPlatformDependency = { Object dep ->
    String category = getDependencyCategory(dep)
    return [ENFORCED_PLATFORM].contains(category)
}

project.ext.isDocumentationDependency = { Object dep ->
    String category = getDependencyCategory(dep)
    return [DOCUMENTATION].contains(category)
}

project.ext.isVerificationDependency = { Object dep ->
    String category = getDependencyCategory(dep)
    return [VERIFICATION].contains(category)
}


Closure<JSONArray> loadJsonFromUrl = { Object untypedUrl ->
    URL url = project.uri(untypedUrl).toURL()
    URLConnection connection = url.openConnection()
    connection.connectTimeout = 5000
    connection.readTimeout = 15000
    connection.useCaches = false
    try {
        String content = connection.inputStream.getText('UTF-8')
        return new JSONTokener(content).nextValue()
    } finally {
        if (connection instanceof HttpURLConnection) {
            connection.disconnect()
        }
    }
}

project.ext.getAllGradleVersions = {
    synchronized (MUTEX) {
        File cacheFile = project.file("${project.buildDir}/gradle-versions.list")
        if (cacheFile.exists()) {
            return cacheFile.getText('UTF-8')
                .split('\n')
                .collect { it.trim() }
                .findAll { !it.isEmpty() }
                .collect { GradleVersion.version(it) }
        }

        List<GradleVersion> result = []

        JSONArray versionObjects = loadJsonFromUrl('https://services.gradle.org/versions/all')
        for (JSONObject versionObject : versionObjects) {
            if (versionObject.optBoolean('snapshot')) continue
            if (versionObject.optBoolean('nightly')) continue
            if (versionObject.optBoolean('releaseNightly')) continue
            if (versionObject.optBoolean('broken')) continue
            if (!versionObject.optString('milestoneFor').isEmpty()) continue
            if (!versionObject.optBoolean('activeRc') && !versionObject.optString('rcFor').isEmpty()) continue

            String version = versionObject.getString('version')
            if (version.containsIgnoreCase('milestone')) continue
            if (version.startsWith('0.')) continue

            GradleVersion gradleVersion = GradleVersion.version(version)
            result.add(gradleVersion)
        }

        result.sort(Comparator.reverseOrder())

        cacheFile.parentFile.mkdirs()
        cacheFile.setText(
            result.collect { it.version }.join('\n'),
            'UTF-8'
        )

        return result
    }
}.memoize()

Closure<List<String>> getNodeJsVersions = { Closure<Boolean> filter = { true } ->
    List<Semver> result = []

    JSONArray versionObjects = loadJsonFromUrl('https://nodejs.org/download/release/index.json')
    for (JSONObject versionObject : versionObjects) {
        if (filter(versionObject)) {
            String version = versionObject.getString('version')
            while (version.startsWith('v')) {
                version = version.substring(1)
            }

            Semver semver = new Semver(version)
            if (!semver.isStable()) continue

            result.add(semver)
        }
    }

    result.sort(Comparator.reverseOrder())

    return result.collect { it.toString() }
}

project.ext.getAllNodeJsVersions = {
    synchronized (MUTEX) {
        File cacheFile = project.file("${project.buildDir}/nodejs-all-versions.list")
        if (cacheFile.exists()) {
            return cacheFile.getText('UTF-8')
                .split('\n')
                .collect { it.trim() }
                .findAll { !it.isEmpty() }
        }

        List<String> result = getNodeJsVersions()

        if (result.isEmpty()) {
            throw new GradleException('No versions of Node.js found')
        }

        cacheFile.parentFile.mkdirs()
        cacheFile.setText(
            result.join('\n'),
            'UTF-8'
        )

        return result
    }
}.memoize()

project.ext.getLtsNodeJsVersions = {
    synchronized (MUTEX) {
        File cacheFile = project.file("${project.buildDir}/nodejs-lts-versions.list")
        if (cacheFile.exists()) {
            return cacheFile.getText('UTF-8')
                .split('\n')
                .collect { it.trim() }
                .findAll { !it.isEmpty() }
        }

        List<String> allVersions = getNodeJsVersions { JSONObject versionObject ->
            versionObject.has('lts') && versionObject.get('lts') != false
        }

        Map<String, String> majorLtsVersions = new LinkedHashMap<>()
        allVersions.forEach { String version ->
            String majorVersion = version.split(/\./)[0]
            majorLtsVersions.putIfAbsent(majorVersion, version)
        }

        Collection<String> result = majorLtsVersions.values()

        if (result.isEmpty()) {
            throw new GradleException('No LTS versions of Node.js found')
        }

        cacheFile.parentFile.mkdirs()
        cacheFile.setText(
            result.join('\n'),
            'UTF-8'
        )

        return result
    }
}.memoize()


ConcurrentMap<String, String> getGradleApiDependencyVersionCache = new ConcurrentHashMap<>()
allprojects {
    project.ext.getGradleApiDependencyVersion = { String notation ->
        return getGradleApiDependencyVersionCache.computeIfAbsent(notation) {
            String gradleApiVersion = project.configurations.projectDependencyConstraints
                .allDependencyConstraints
                .find { "${it.group}:${it.name}" == 'name.remal.gradle-api:gradle-api' }
                ?.version
            if (gradleApiVersion == null) throw new GradleException('Unknown Gradle API version')

            Configuration tempConf = project.configurations.detachedConfiguration(
                project.dependencies.create("name.remal.gradle-api:gradle-api:$gradleApiVersion")
            )

            String version = tempConf.resolvedConfiguration
                .resolvedArtifacts
                .collect { it.moduleVersion }
                .collect { it.id }
                .find { "${it.group}:*" == notation || "${it.group}:${it.name}" == notation }
                ?.version
            if (version == null) throw new GradleException("Gradle API dependency not found: $notation")
            return version
        }
    }
}
