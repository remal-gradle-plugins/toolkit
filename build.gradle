import static java.lang.reflect.Modifier.isAbstract

import com.google.common.reflect.Invokable
import com.google.common.reflect.TypeToken
import java.lang.reflect.Method
import java.lang.reflect.Type
import java.lang.reflect.TypeVariable

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

buildscript {
    dependencies {
        classpath 'name.remal.gradle-plugins.test-source-sets:test-source-sets:2.2.3'
        classpath 'com.gradle.publish:plugin-publish-plugin:0.21.0'
        classpath 'gradle.plugin.org.jetbrains.gradle.plugin.idea-ext:gradle-idea-ext:1.1.4'
        classpath 'name.remal:gradle-plugins:1.6.0'
        classpath 'io.github.gradle-nexus:publish-plugin:1.1.0'
        classpath 'net.ltgt.gradle:gradle-errorprone-plugin:2.0.2'
        classpath('com.google.guava:guava:31.1-jre') {
            exclude(group: 'com.google.code.findbugs')
            exclude(group: 'org.checkerframework')
            exclude(group: 'com.google.errorprone')
            exclude(group: 'com.google.j2objc')
        }
    }
    repositories {
        gradlePluginPortal()
        mavenCentral()
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

allprojects {
    group = "name.remal.gradle-plugins.${rootProject.name}"
    version = '0-SNAPSHOT'
}

apply from: 'gradle/properties.gradle'
apply from: 'gradle/ci.gradle'
apply from: 'gradle/dependencies.gradle'
apply from: 'gradle/java.gradle'
apply from: 'gradle/classes-relocation.gradle'
apply from: 'gradle/groovy.gradle'
apply from: 'gradle/checkstyle.gradle'
apply from: 'gradle/errorprone.gradle'
apply from: 'gradle/gradle-plugin.gradle'
apply from: 'gradle/base-package.gradle'
apply from: 'gradle/publish-gradle-plugin.gradle'
apply from: 'gradle/publish-maven.gradle'
apply from: 'gradle/publish-maven-bom.gradle'
apply from: 'gradle/publish-maven-central.gradle'
apply from: 'gradle/signing.gradle'
apply from: 'gradle/process-readme.gradle'
apply from: 'gradle/renovate.gradle'
apply from: 'gradle/ide.gradle'

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

allprojects {
    pluginManager.withPlugin('java') {
        dependencies {
            optional 'name.remal.gradle-api:gradle-api'

            annotationProcessorAll 'com.google.auto.service:auto-service'
            compileOnlyAll 'com.google.auto.service:auto-service-annotations'
            annotationProcessorAll 'org.immutables:value'
            compileOnlyAll 'org.immutables:value-annotations'
            compileOnlyAll 'org.immutables:builder'

            relocateClasses 'org.apache.commons:commons-lang3'
            relocateClasses 'org.apache.commons:commons-text'
            relocateClasses 'com.google.guava:guava'
            relocateClasses 'org.ow2.asm:asm'


            testImplementation 'org.apache.commons:commons-lang3'
            testImplementation 'com.google.guava:guava'
        }
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

apply plugin: 'java-library'
apply plugin: 'maven-publish'
apply plugin: 'name.remal.classes-relocation'
apply plugin: 'name.remal.generate-sources'

dependencies {
    optional 'com.puppycrawl.tools:checkstyle'

    relocateClasses 'org.jdom:jdom'
    relocateClasses 'net.htmlparser.jericho:jericho-html'

    testImplementation project(':testkit')
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

configurations.create('includeClasses') { Configuration conf ->
    conf.description("Classes of these dependencies will be directly included to result JAR")
    conf.allDependencies.all { Dependency dep ->
        if (!dep instanceof ProjectDependency) {
            throw new GradleException("${conf} can contain NOT project depndency: ${dep}")
        }
    }
}

dependencies {
    compileOnly project(':toolkit--java-common')
    includeClasses project(':toolkit--java-common')
    includeClasses project(':toolkit--java-9')
}

DomainObjectSet<ProjectDependency> includeClassesDependencies = configurations.includeClasses.allDependencies.withType(ProjectDependency)

sourceSets.main.allSource.srcDirs(
    project.provider {
        includeClassesDependencies.collect { it.dependencyProject.sourceSets.main.allSource.srcDirs }
    }
)
sourceSets.main.output.classesDirs.from(
    project.provider {
        includeClassesDependencies.collect { it.dependencyProject.sourceSets.main.output.classesDirs }
    }
)
sourceSets.main.output.generatedSourcesDirs.from(
    project.provider {
        includeClassesDependencies.collect { it.dependencyProject.sourceSets.main.output.resourcesDir }
    }
)
sourceSets.main.output.generatedSourcesDirs.from(
    project.provider {
        includeClassesDependencies.collect { it.dependencyProject.sourceSets.main.output.generatedSourcesDirs }
    }
)

[
    'classes',
    'javadocJar',
    'sourcesJar',
].forEach { String taskName ->
    tasks.matching { it.name == taskName }.all {
        dependsOn(
            project.provider {
                includeClassesDependencies.collect { it.dependencyProject.tasks.matching { it.name == taskName } }
            }
        )
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

tasks.named('generateJava') {
    int typedMethodMaxParamsCount = 10
    classFile('name.remal.gradleplugins.toolkit.reflection', 'MembersFinder') {
        it.writePackage()
        it.println("")
        it.writeImport('java.util.Optional')
        it.writeImport('javax.annotation.CheckForNull')
        it.writeImport('javax.annotation.Nullable')
        it.writeImport('lombok.val')
        it.println("")
        it.writeSuppressWarnings("checkstyle:LineLength", "checkstyle:RightCurlyAlone")
        it.writeBlock("public interface ${it.simpleName}") {
            // get*() methods:
            (0..typedMethodMaxParamsCount).forEach { paramsCount ->
                it.println("")
                it.writeBlock("static <T, R${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}> TypedMethod${paramsCount}<T, R${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}> getMethod(Class<T> type, Class<R> returnType, String name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", Class<P$it> paramType$it" }.join("")})") {
                    it.println("val method = MembersFinderHelpers.getMethod(type, false, returnType, name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", paramType$it" }.join("")});")
                    it.println("return new TypedMethod${paramsCount}<>(method);")
                }
            }

            it.println("")
            (0..typedMethodMaxParamsCount).forEach { paramsCount ->
                it.println("")
                it.writeBlock("static <T${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}> TypedVoidMethod${paramsCount}<T${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}> getMethod(Class<T> type, String name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", Class<P$it> paramType$it" }.join("")})") {
                    it.println("val method = MembersFinderHelpers.getMethod(type, false, null, name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", paramType$it" }.join("")});")
                    it.println("return new TypedVoidMethod${paramsCount}<>(method);")
                }
            }

            it.println("")
            (0..typedMethodMaxParamsCount).forEach { paramsCount ->
                it.println("")
                it.writeBlock("static <R${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}> TypedStaticMethod${paramsCount}<R${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}> getStaticMethod(Class<?> type, Class<R> returnType, String name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", Class<P$it> paramType$it" }.join("")})") {
                    it.println("val method = MembersFinderHelpers.getMethod(type, true, returnType, name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", paramType$it" }.join("")});")
                    it.println("return new TypedStaticMethod${paramsCount}<>(method);")
                }
            }

            it.println("")
            (0..typedMethodMaxParamsCount).forEach { paramsCount ->
                it.println("")
                it.writeBlock("static ${paramsCount == 0 ? '' : '<' + (1..paramsCount).collect { "P$it" }.join(", ") + '>'} TypedStaticVoidMethod${paramsCount}${paramsCount == 0 ? '' : '<' + (1..paramsCount).collect { "P$it" }.join(", ") + '>'} getStaticMethod(Class<?> type, String name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", Class<P$it> paramType$it" }.join("")})") {
                    it.println("val method = MembersFinderHelpers.getMethod(type, true, null, name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", paramType$it" }.join("")});")
                    it.println("return new TypedStaticVoidMethod${paramsCount}${paramsCount == 0 ? '' : '<>'}(method);")
                }
            }

            // find*() methods:
            it.println("")
            (0..typedMethodMaxParamsCount).forEach { paramsCount ->
                it.println("")
                it.println("@Nullable")
                it.writeBlock("static <T, R${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}> TypedMethod${paramsCount}<T, R${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}> findMethod(Class<T> type, Class<R> returnType, String name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", Class<P$it> paramType$it" }.join("")})") {
                    it.println("val method = MembersFinderHelpers.findMethod(type, false, returnType, name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", paramType$it" }.join("")});")
                    it.println("return method != null ? new TypedMethod${paramsCount}<>(method) : null;")
                }
            }

            it.println("")
            (0..typedMethodMaxParamsCount).forEach { paramsCount ->
                it.println("")
                it.println("@Nullable")
                it.writeBlock("static <T${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}> TypedVoidMethod${paramsCount}<T${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}> findMethod(Class<T> type, String name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", Class<P$it> paramType$it" }.join("")})") {
                    it.println("val method = MembersFinderHelpers.findMethod(type, false, null, name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", paramType$it" }.join("")});")
                    it.println("return method != null ? new TypedVoidMethod${paramsCount}<>(method) : null;")
                }
            }

            it.println("")
            (0..typedMethodMaxParamsCount).forEach { paramsCount ->
                it.println("")
                it.println("@Nullable")
                it.writeBlock("static <R${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}> TypedStaticMethod${paramsCount}<R${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}> findStaticMethod(Class<?> type, Class<R> returnType, String name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", Class<P$it> paramType$it" }.join("")})") {
                    it.println("val method = MembersFinderHelpers.findMethod(type, true, returnType, name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", paramType$it" }.join("")});")
                    it.println("return method != null ? new TypedStaticMethod${paramsCount}<>(method) : null;")
                }
            }

            it.println("")
            (0..typedMethodMaxParamsCount).forEach { paramsCount ->
                it.println("")
                it.println("@Nullable")
                it.writeBlock("static ${paramsCount == 0 ? '' : '<' + (1..paramsCount).collect { "P$it" }.join(", ") + '>'} TypedStaticVoidMethod${paramsCount}${paramsCount == 0 ? '' : '<' + (1..paramsCount).collect { "P$it" }.join(", ") + '>'} findStaticMethod(Class<?> type, String name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", Class<P$it> paramType$it" }.join("")})") {
                    it.println("val method = MembersFinderHelpers.findMethod(type, true, null, name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", paramType$it" }.join("")});")
                    it.println("return method != null ? new TypedStaticVoidMethod${paramsCount}${paramsCount == 0 ? '' : '<>'}(method) : null;")
                }
            }

            // getOptional*() methods:
            it.println("")
            (0..typedMethodMaxParamsCount).forEach { paramsCount ->
                it.println("")
                it.writeBlock("static <T, R${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}> Optional<TypedMethod${paramsCount}<T, R${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}>> getOptionalMethod(Class<T> type, Class<R> returnType, String name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", Class<P$it> paramType$it" }.join("")})") {
                    it.println("return Optional.ofNullable(findMethod(type, returnType, name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", paramType$it" }.join("")}));")
                }
            }

            it.println("")
            (0..typedMethodMaxParamsCount).forEach { paramsCount ->
                it.println("")
                it.writeBlock("static <T${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}> Optional<TypedVoidMethod${paramsCount}<T${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}>> getOptionalMethod(Class<T> type, String name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", Class<P$it> paramType$it" }.join("")})") {
                    it.println("return Optional.ofNullable(findMethod(type, name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", paramType$it" }.join("")}));")
                }
            }

            it.println("")
            (0..typedMethodMaxParamsCount).forEach { paramsCount ->
                it.println("")
                it.writeBlock("static <R${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}> Optional<TypedStaticMethod${paramsCount}<R${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}>> getOptionalStaticMethod(Class<?> type, Class<R> returnType, String name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", Class<P$it> paramType$it" }.join("")})") {
                    it.println("return Optional.ofNullable(findStaticMethod(type, returnType, name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", paramType$it" }.join("")}));")
                }
            }

            it.println("")
            (0..typedMethodMaxParamsCount).forEach { paramsCount ->
                it.println("")
                it.writeBlock("static ${paramsCount == 0 ? '' : '<' + (1..paramsCount).collect { "P$it" }.join(", ") + '>'} Optional<TypedStaticVoidMethod${paramsCount}${paramsCount == 0 ? '' : '<' + (1..paramsCount).collect { "P$it" }.join(", ") + '>'}> getOptionalStaticMethod(Class<?> type, String name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", Class<P$it> paramType$it" }.join("")})") {
                    it.println("return Optional.ofNullable(findStaticMethod(type, name${paramsCount == 0 ? '' : (1..paramsCount).collect { ", paramType$it" }.join("")}));")
                }
            }
        }
    }

    (0..typedMethodMaxParamsCount).forEach { paramsCount ->
        classFile('name.remal.gradleplugins.toolkit.reflection', "TypedMethod${paramsCount}") {
            it.writePackage()
            it.println("")
            it.writeStaticImport('name.remal.gradleplugins.toolkit.reflection.ReflectionUtils', 'isStatic')
            it.println("")
            it.writeImport('java.lang.reflect.Method')
            it.writeImport('javax.annotation.CheckForNull')
            it.writeImport('lombok.SneakyThrows')
            it.println("")
            it.writeSuppressWarnings("checkstyle:LineLength", "checkstyle:RightCurlyAlone")
            it.writeBlock("public final class ${it.simpleName}<T, R${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}> extends AbstractTypedMethod") {
                it.writeBlock("${it.simpleName}(Method method)") {
                    it.println("super(method);")
                    it.writeBlock("if (isStatic(method))") {
                        it.println("throw new IllegalArgumentException(\"Static method: \" + method);")
                    }
                }

                it.println("")
                it.println("@CheckForNull")
                it.println("@SneakyThrows")
                it.writeSuppressWarnings("unchecked")
                it.writeBlock("public final R invoke(T target${paramsCount == 0 ? '' : (1..paramsCount).collect { ", @CheckForNull P$it param$it" }.join("")})") {
                    it.println("return (R) method.invoke(target${paramsCount == 0 ? '' : (1..paramsCount).collect { ", param$it" }.join("")});")
                }
            }
        }

        classFile('name.remal.gradleplugins.toolkit.reflection', "TypedVoidMethod${paramsCount}") {
            it.writePackage()
            it.println("")
            it.writeStaticImport('name.remal.gradleplugins.toolkit.reflection.ReflectionUtils', 'isStatic')
            it.println("")
            it.writeImport('java.lang.reflect.Method')
            it.writeImport('javax.annotation.CheckForNull')
            it.writeImport('lombok.SneakyThrows')
            it.println("")
            it.writeSuppressWarnings("checkstyle:LineLength", "checkstyle:RightCurlyAlone")
            it.writeBlock("public final class ${it.simpleName}<T${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}> extends AbstractTypedMethod") {
                it.writeBlock("${it.simpleName}(Method method)") {
                    it.println("super(method);")
                    it.writeBlock("if (isStatic(method))") {
                        it.println("throw new IllegalArgumentException(\"Static method: \" + method);")
                    }
                }

                it.println("")
                it.println("@SneakyThrows")
                it.writeBlock("public final void invoke(T target${paramsCount == 0 ? '' : (1..paramsCount).collect { ", @CheckForNull P$it param$it" }.join("")})") {
                    it.println("method.invoke(target${paramsCount == 0 ? '' : (1..paramsCount).collect { ", param$it" }.join("")});")
                }
            }
        }

        classFile('name.remal.gradleplugins.toolkit.reflection', "TypedStaticMethod${paramsCount}") {
            it.writePackage()
            it.println("")
            it.writeStaticImport('name.remal.gradleplugins.toolkit.reflection.ReflectionUtils', 'isNotStatic')
            it.println("")
            it.writeImport('java.lang.reflect.Method')
            it.writeImport('javax.annotation.CheckForNull')
            it.writeImport('lombok.SneakyThrows')
            it.println("")
            it.writeSuppressWarnings("checkstyle:LineLength", "checkstyle:RightCurlyAlone")
            it.writeBlock("public final class ${it.simpleName}<R${paramsCount == 0 ? '' : (1..paramsCount).collect { ", P$it" }.join("")}> extends AbstractTypedMethod") {
                it.writeBlock("${it.simpleName}(Method method)") {
                    it.println("super(method);")
                    it.writeBlock("if (isNotStatic(method))") {
                        it.println("throw new IllegalArgumentException(\"Not a static method: \" + method);")
                    }
                }

                it.println("")
                it.println("@CheckForNull")
                it.println("@SneakyThrows")
                it.writeSuppressWarnings("unchecked")
                it.writeBlock("public final R invoke(${paramsCount == 0 ? '' : (1..paramsCount).collect { "@CheckForNull P$it param$it" }.join(", ")})") {
                    it.println("return (R) method.invoke(null${paramsCount == 0 ? '' : (1..paramsCount).collect { ", param$it" }.join("")});")
                }
            }
        }

        classFile('name.remal.gradleplugins.toolkit.reflection', "TypedStaticVoidMethod${paramsCount}") {
            it.writePackage()
            it.println("")
            it.writeStaticImport('name.remal.gradleplugins.toolkit.reflection.ReflectionUtils', 'isNotStatic')
            it.println("")
            it.writeImport('java.lang.reflect.Method')
            it.writeImport('javax.annotation.CheckForNull')
            it.writeImport('lombok.SneakyThrows')
            it.println("")
            it.writeSuppressWarnings("checkstyle:LineLength", "checkstyle:RightCurlyAlone")
            it.writeBlock("public final class ${it.simpleName}${paramsCount == 0 ? '' : '<' + (1..paramsCount).collect { "P$it" }.join(", ") + '>'} extends AbstractTypedMethod") {
                it.writeBlock("${it.simpleName}(Method method)") {
                    it.println("super(method);")
                    it.writeBlock("if (isNotStatic(method))") {
                        it.println("throw new IllegalArgumentException(\"Not a static method: \" + method);")
                    }
                }

                it.println("")
                it.println("@CheckForNull")
                it.println("@SneakyThrows")
                it.writeBlock("public final void invoke(${paramsCount == 0 ? '' : (1..paramsCount).collect { "@CheckForNull P$it param$it" }.join(", ")})") {
                    it.println("method.invoke(null${paramsCount == 0 ? '' : (1..paramsCount).collect { ", param$it" }.join("")});")
                }
            }
        }
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

tasks.named('generateJava') {
    List<Class<?>> lambdaClasses = [
        Class.forName('org.gradle.api.Action'),
        Class.forName('java.lang.Runnable'),
        Class.forName('java.util.concurrent.Callable'),
        Class.forName('java.util.function.BiConsumer'),
        Class.forName('java.util.function.BiFunction'),
        Class.forName('java.util.function.BinaryOperator'),
        Class.forName('java.util.function.BiPredicate'),
        Class.forName('java.util.function.BooleanSupplier'),
        Class.forName('java.util.function.Consumer'),
        Class.forName('java.util.function.DoubleBinaryOperator'),
        Class.forName('java.util.function.DoubleConsumer'),
        Class.forName('java.util.function.DoubleFunction'),
        Class.forName('java.util.function.DoublePredicate'),
        Class.forName('java.util.function.DoubleSupplier'),
        Class.forName('java.util.function.DoubleToIntFunction'),
        Class.forName('java.util.function.DoubleToLongFunction'),
        Class.forName('java.util.function.DoubleUnaryOperator'),
        Class.forName('java.util.function.Function'),
        Class.forName('java.util.function.IntBinaryOperator'),
        Class.forName('java.util.function.IntConsumer'),
        Class.forName('java.util.function.IntFunction'),
        Class.forName('java.util.function.IntPredicate'),
        Class.forName('java.util.function.IntSupplier'),
        Class.forName('java.util.function.IntToDoubleFunction'),
        Class.forName('java.util.function.IntToLongFunction'),
        Class.forName('java.util.function.IntUnaryOperator'),
        Class.forName('java.util.function.LongBinaryOperator'),
        Class.forName('java.util.function.LongConsumer'),
        Class.forName('java.util.function.LongFunction'),
        Class.forName('java.util.function.LongPredicate'),
        Class.forName('java.util.function.LongSupplier'),
        Class.forName('java.util.function.LongToDoubleFunction'),
        Class.forName('java.util.function.LongToIntFunction'),
        Class.forName('java.util.function.LongUnaryOperator'),
        Class.forName('java.util.function.ObjDoubleConsumer'),
        Class.forName('java.util.function.ObjIntConsumer'),
        Class.forName('java.util.function.ObjLongConsumer'),
        Class.forName('java.util.function.Predicate'),
        Class.forName('java.util.function.Supplier'),
        Class.forName('java.util.function.ToDoubleBiFunction'),
        Class.forName('java.util.function.ToDoubleFunction'),
        Class.forName('java.util.function.ToIntBiFunction'),
        Class.forName('java.util.function.ToIntFunction'),
        Class.forName('java.util.function.ToLongBiFunction'),
        Class.forName('java.util.function.ToLongFunction'),
        Class.forName('java.util.function.UnaryOperator'),
    ].sort { it.name }
    classFile('name.remal.gradleplugins.toolkit', 'SneakyThrowUtils') {
        it.writePackage()
        it.println("")
        it.writeStaticImport('javax.annotation.meta.When', 'UNKNOWN')
        it.writeStaticImport('lombok.AccessLevel', 'PRIVATE')
        it.println("")
        (lambdaClasses.collect { it.name } + [
            'lombok.Lombok',
            'lombok.NoArgsConstructor',
            'javax.annotation.Nonnull',
        ]).sort().findAll { !it.matches(/^java\.lang\.[^.]+$/) }.forEach { name -> it.writeImport(name) }
        it.println("")
        it.println("@NoArgsConstructor(access = PRIVATE)")
        it.writeSuppressWarnings("checkstyle:LineLength", "checkstyle:RightCurlyAlone", "overloads")
        it.writeBlock("public abstract class ${it.simpleName}") {
            it.println("")
            it.println("/**")
            it.println(" * See {@link Lombok#sneakyThrow(Throwable)}.")
            it.println(" */")
            it.writeBlock("public static RuntimeException sneakyThrow(Throwable exception)") {
                it.println("return sneakyThrow0(exception);")
            }
            it.println("")
            it.writeSuppressWarnings("unchecked", "TypeParameterUnusedInFormals")
            it.writeBlock("private static <T extends Throwable> T sneakyThrow0(Throwable exception) throws T") {
                it.println("throw (T) exception;")
            }

            lambdaClasses.forEach { lambdaClass ->
                Method method = lambdaClass.methods.find { isAbstract(it.modifiers) }
                if (method == null) throw new GradleException("Abstract method can't be found for $lambdaClass")

                List<TypeVariable> typeParams = lambdaClass.typeParameters.collect()
                String typeParamsString = typeParams.isEmpty() ? '' : '<' + typeParams.join(', ') + '>'

                Invokable resolvedMethod = TypeToken.of(lambdaClass)
                    .getSupertype(method.declaringClass)
                    .method(method)

                String paramsString = method.parameters.collect().withIndex().collect { param, index ->
                    Type type = resolvedMethod.genericParameterTypes[index]
                    boolean primitive = TypeToken.of(type).rawType.primitive
                    String annotations = primitive ? '' : '@Nonnull(when = UNKNOWN) '
                    return "${annotations}${type} ${param.name}"
                }.join(', ')
                String paramNamesString = method.parameters.collect { it.name }.join(', ')

                it.println("")
                it.println("")
                it.println("@FunctionalInterface")
                it.writeBlock("public interface SneakyThrows${lambdaClass.simpleName}${typeParamsString}") {
                    if (!resolvedMethod.returnType.primitive) {
                        it.println("@Nonnull(when = UNKNOWN)")
                    }
                    it.println("${resolvedMethod.genericReturnType} ${method.name}($paramsString) throws Throwable;")
                }
                it.println("")
                it.writeBlock("public static${!typeParamsString.isEmpty() ? ' ' + typeParamsString : ''} ${lambdaClass.simpleName}${typeParamsString} sneakyThrows(SneakyThrows${lambdaClass.simpleName}${typeParamsString} ${lambdaClass.simpleName.uncapitalize()})") {
                    it.println("return ($paramNamesString) -> {")
                    it.println("    try {")
                    it.println("        ${resolvedMethod.genericReturnType != void.class ? 'return ' : ''}${lambdaClass.simpleName.uncapitalize()}.${method.name}($paramNamesString);")
                    it.println("    } catch (Throwable exception) {")
                    it.println("        throw sneakyThrow(exception);")
                    it.println("    }")
                    it.println("};")
                }
            }
        }
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

tasks.named('generateResources') {
    binaryFile('name/remal/gradleplugins/toolkit/issues/checkstyle.xsl') { outputStream ->
        String resourceName = 'checkstyle-noframes-sorted.xsl'
        InputStream inputStream = Checkstyle.getClassLoader().getResourceAsStream(resourceName)
        if (inputStream == null) {
            throw new IllegalStateException("Resource can't be found: " + resourceName)
        }
        inputStream.withCloseable { outputStream << it }
    }
}
