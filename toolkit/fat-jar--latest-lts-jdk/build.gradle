import static org.objectweb.asm.ClassReader.SKIP_CODE
import static org.objectweb.asm.ClassReader.SKIP_DEBUG
import static org.objectweb.asm.ClassReader.SKIP_FRAMES

import java.util.zip.ZipEntry
import java.util.zip.ZipFile
import org.objectweb.asm.ClassReader
import org.objectweb.asm.tree.ClassNode

apply plugin: 'java-library'
apply plugin: 'name.remal.test-source-sets'
apply plugin: 'name.remal.generate-sources'

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

buildscript {
    dependencies {
        classpath platform("org.ow2.asm:asm-bom:9.7.1")
        classpath 'org.ow2.asm:asm-tree'
    }
    repositories {
        mavenCentral()
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

Provider<JavaCompiler> latestLtsJavaCompiler = javaToolchains.compilerFor {
    languageVersion = provider {
        file('.tool-versions').getText('UTF-8').split(/[\n\r]+/)
            .collect { it.replaceFirst(/#.*/, '').trim() }
            .find { it.find(/^java\s+/) }
            ?.replaceFirst(/^\S+\s+(?:\D+-)?(\d+).*$/, '$1')
            ?.with { JavaLanguageVersion.of(it) }
    }
}
Provider<File> latestLtsJmodsDir = latestLtsJavaCompiler.map {
    it.metadata.installationPath.dir('jmods').asFile
        .with {
            if (!it.isDirectory()) {
                throw new IllegalStateException("Not a directory: $it")
            }
            return it
        }
}
FileTree jmodsFileTree = files(latestLtsJmodsDir).asFileTree
    .matching { include('*.jmod') }

generateSources.forMainSourceSet.java {
    withInputClasspathFiles('jmodsFileTree', jmodsFileTree)

    classFile(project.calculateBaseJavaPackage() + '.reflection', 'LatestLtsJdkModules') {
        Map<String, Set<String>> modulePackages = new TreeMap<>()
        jmodsFileTree.files.forEach { File jmodFile ->
            new ZipFile(jmodFile).withCloseable { zipFile ->
                String moduleInfoEntryName = 'classes/module-info.class'
                ZipEntry moduleInfoZipEntry = zipFile.getEntry(moduleInfoEntryName)
                if (moduleInfoZipEntry == null) {
                    throw new IllegalStateException("Entry `$moduleInfoEntryName` can't be found in $jmodFile")
                }

                /*
                Set<String> packages = new TreeSet<>()
                zipFile.entries().collect().forEach { ZipEntry zipEntry ->
                    String name = zipEntry.name
                    if (!name.startsWith('classes/')
                        || !name.endsWith('.class')
                        || name.endsWith('/module-info.class')
                    ) {
                        return
                    }

                    String className = name.substring('classes/'.length(), name.length() - '.class'.length()).replace('/', '.')
                    int packageEndPos = className.lastIndexOf('.')
                    String packageName = packageEndPos >= 0 ? className.substring(0, packageEndPos) : ''
                    packages.add(packageName)
                }
                */

                zipFile.getInputStream(moduleInfoZipEntry).withCloseable { InputStream input ->
                    ClassNode classNode = new ClassNode()
                    new ClassReader(input).accept(classNode, SKIP_CODE | SKIP_DEBUG | SKIP_FRAMES)

                    modulePackages[classNode.module.name] = (classNode.module.exports ?: [])
                        .findAll { !it.modules?.size() }
                        .collect { it.packaze.replace('/', '.') }
                }
            }
        }
        modulePackages.values().removeIf { it.isEmpty() }

        Map<String, String> packageModules = new TreeMap<>()
        modulePackages.forEach { moduleName, packageNames ->
            packageNames.forEach { packageName ->
                packageModules.putIfAbsent(packageName, moduleName)
            }
        }

        addStaticImport("java.util.Arrays", "asList")
        addStaticImport("java.util.Collections", "unmodifiableMap")
        addStaticImport("java.util.Collections", "unmodifiableSet")
        addStaticImport("lombok.AccessLevel", "PRIVATE")

        addImport("java.util.LinkedHashMap")
        addImport("java.util.LinkedHashSet")
        addImport("java.util.Map")
        addImport("java.util.Set")
        addImport("lombok.NoArgsConstructor")
        addImport("lombok.val")
        addImport("name.remal.gradle_plugins.toolkit.annotations.ReliesOnExternalDependency")

        line("@ReliesOnExternalDependency")
        line("@NoArgsConstructor(access = PRIVATE)")
        suppressWarningsLine("checkstyle:LineLength", "checkstyle:RightCurlyAlone", "java:S107", "java:S1128", "java:S1611")
        block("abstract class ${simpleName}") {

            /*
            line()
            line("public static final Map<String, Set<String>> LATEST_LTS_JDK_MODULE_PACKAGES;")
            line()
            block("static") {
                line("val mapping = new LinkedHashMap<String, Set<String>>();")
                modulePackages.forEach { moduleName, packageNames ->
                    line("mapping.put(\"${escapeString(moduleName)}\", unmodifiableSet(new LinkedHashSet<>(asList(")
                    line("    " + packageNames.collect { name -> "\"${escapeString(name)}\"" }.join(',\n    '))
                    line("))));")
                }
                line("LATEST_LTS_JDK_MODULE_PACKAGES = unmodifiableMap(mapping);")
            }
            */

            line()
            line("public static final Map<String, String> LATEST_LTS_JDK_PACKAGE_MODULES;")
            line()
            block("static") {
                line("val mapping = new LinkedHashMap<String, String>();")
                packageModules.forEach { packageName, moduleName ->
                    line("mapping.put(\"${escapeString(packageName)}\", \"${escapeString(moduleName)}\");")
                }
                line("LATEST_LTS_JDK_PACKAGE_MODULES = unmodifiableMap(mapping);")
            }

            line()
        }
    }
}
